import { g as IS_SAFARI, h as isHLSSrc, j as getNumberOfDecimalPlaces, L as ListSymbol, k as isMediaStream } from './vidstack-bfe4dd65.js';
import { y as isUndefined, A as isNumber, B as useDisposalBin, e as effect, o as onDispose, l as listenEvent, D as DOMEvent, E as isNil, f as setAttribute, k as isString } from './vidstack-4af9f92b.js';

class RAFLoop {
  constructor(_callback) {
    this.Wg = _callback;
  }
  Cb() {
    if (!isUndefined(this.Wb))
      return;
    this.Bj();
  }
  Db() {
    if (isNumber(this.Wb))
      window.cancelAnimationFrame(this.Wb);
    this.Wb = void 0;
  }
  Bj() {
    this.Wb = window.requestAnimationFrame(() => {
      if (isUndefined(this.Wb))
        return;
      this.Wg();
      this.Bj();
    });
  }
}

class HTMLMediaEvents {
  constructor(_provider, _ctx) {
    this.Lf = useDisposalBin();
    this.Yf = false;
    this._f = false;
    this.$f = false;
    this.Zf = new RAFLoop(this.eg.bind(this));
    this.cg = void 0;
    this.xg = void 0;
    this.bb = _provider;
    this.Wf = _ctx;
    this.fg();
    effect(this.gg.bind(this));
    onDispose(this.Pf.bind(this));
  }
  get v() {
    return this.bb.media;
  }
  get vc() {
    return this.Wf.delegate;
  }
  Pf() {
    this._f = false;
    this.$f = false;
    this.Zf.Db();
    this.Lf.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  eg() {
    const newTime = this.bb.currentTime;
    if (this.Wf.$state.currentTime() !== newTime)
      this.Xf(newTime);
  }
  fg() {
    this.Vf("loadstart", this.hf);
    this.Vf("abort", this.bg);
    this.Vf("emptied", this.hg);
    this.Vf("error", this.Pc);
  }
  ig() {
    if (this._f)
      return;
    this.Lf.add(
      this.Vf("loadeddata", this.jg),
      this.Vf("loadedmetadata", this.kg),
      this.Vf("canplay", this.Ic),
      this.Vf("canplaythrough", this.lg),
      this.Vf("durationchange", this.mg),
      this.Vf("play", this.T),
      this.Vf("progress", this.ng),
      this.Vf("stalled", this.og),
      this.Vf("suspend", this.pg)
    );
    this._f = true;
  }
  qg() {
    if (this.$f)
      return;
    this.Lf.add(
      this.Vf("pause", this.U),
      this.Vf("playing", this.rg),
      this.Vf("ratechange", this.sg),
      this.Vf("seeked", this.tg),
      this.Vf("seeking", this.ug),
      this.Vf("ended", this.vg),
      this.Vf("volumechange", this.Wc),
      this.Vf("waiting", this.wg)
    );
    this.$f = true;
  }
  Vf(eventType, handler) {
    return listenEvent(
      this.v,
      eventType,
      handler.bind(this)
    );
  }
  yg(event2) {
    return;
  }
  Xf(time, trigger) {
    this.vc.u("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this.Wf.$state.seekableEnd()),
        played: this.v.played
      },
      trigger
    });
  }
  hf(event2) {
    if (this.v.networkState === 3) {
      this.bg(event2);
      return;
    }
    this.ig();
    this.vc.u("load-start", { trigger: event2 });
  }
  bg(event2) {
    this.vc.u("abort", { trigger: event2 });
  }
  hg() {
    this.vc.u("emptied", { trigger: event });
  }
  jg(event2) {
    this.vc.u("loaded-data", { trigger: event2 });
  }
  kg(event2) {
    this.dg();
    this.qg();
    this.vc.u("volume-change", {
      detail: {
        volume: this.v.volume,
        muted: this.v.muted
      }
    });
    this.vc.u("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this.Wf.$state.source())) {
      this.vc.zg(this.ag(), event2);
    }
  }
  ag() {
    return {
      duration: this.v.duration,
      buffered: this.v.buffered,
      seekable: this.v.seekable
    };
  }
  dg() {
    if (this.Wf.$state.live())
      return;
    const isLive = !Number.isFinite(this.v.duration);
    this.vc.u("stream-type-change", {
      detail: isLive ? "live" : "on-demand"
    });
  }
  T(event2) {
    if (!this.Wf.$state.canPlay)
      return;
    this.vc.u("play", { trigger: event2 });
  }
  U(event2) {
    if (this.v.readyState === 1 && !this.Yf)
      return;
    this.Yf = false;
    this.Zf.Db();
    this.vc.u("pause", { trigger: event2 });
  }
  Ic(event2) {
    this.dg();
    this.vc.zg(this.ag(), event2);
  }
  lg(event2) {
    if (this.Wf.$state.started())
      return;
    this.vc.u("can-play-through", {
      trigger: event2,
      detail: this.ag()
    });
  }
  rg(event2) {
    this.Yf = false;
    this.vc.u("playing", { trigger: event2 });
    this.Zf.Cb();
  }
  og(event2) {
    this.vc.u("stalled", { trigger: event2 });
    if (this.v.readyState < 3) {
      this.Yf = true;
      this.vc.u("waiting", { trigger: event2 });
    }
  }
  wg(event2) {
    if (this.v.readyState < 3) {
      this.Yf = true;
      this.vc.u("waiting", { trigger: event2 });
    }
  }
  vg(event2) {
    this.Zf.Db();
    this.Xf(this.v.duration, event2);
    this.vc.u("end", { trigger: event2 });
    if (this.Wf.$state.loop()) {
      this.Ag();
    } else {
      this.vc.u("ended", { trigger: event2 });
    }
  }
  gg() {
    if (this.Wf.$state.paused()) {
      listenEvent(this.v, "timeupdate", this.Bg.bind(this));
    }
  }
  Bg(event2) {
    this.Xf(this.v.currentTime, event2);
  }
  mg(event2) {
    if (this.Wf.$state.ended()) {
      this.Xf(this.v.duration, event2);
    }
    this.vc.u("duration-change", {
      detail: this.v.duration,
      trigger: event2
    });
  }
  Wc(event2) {
    this.vc.u("volume-change", {
      detail: {
        volume: this.v.volume,
        muted: this.v.muted
      },
      trigger: event2
    });
  }
  tg(event2) {
    this.Xf(this.v.currentTime, event2);
    this.vc.u("seeked", {
      detail: this.v.currentTime,
      trigger: event2
    });
    if (Math.trunc(this.v.currentTime) === Math.trunc(this.v.duration) && getNumberOfDecimalPlaces(this.v.duration) > getNumberOfDecimalPlaces(this.v.currentTime)) {
      this.Xf(this.v.duration, event2);
      if (!this.v.ended) {
        this.Wf.player.dispatch(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  ug(event2) {
    this.vc.u("seeking", {
      detail: this.v.currentTime,
      trigger: event2
    });
  }
  ng(event2) {
    this.vc.u("progress", {
      detail: {
        buffered: this.v.buffered,
        seekable: this.v.seekable
      },
      trigger: event2
    });
  }
  Ag() {
    const hasCustomControls = isNil(this.v.controls);
    if (hasCustomControls)
      this.v.controls = false;
    this.Wf.player.dispatch(new DOMEvent("media-loop-request"));
  }
  pg(event2) {
    this.vc.u("suspend", { trigger: event2 });
  }
  sg(event2) {
    this.vc.u("rate-change", {
      detail: this.v.playbackRate,
      trigger: event2
    });
  }
  Pc(event2) {
    const error = this.v.error;
    if (!error)
      return;
    this.vc.u("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
}

class NativeAudioTracks {
  constructor(_provider, _context) {
    this.bb = _provider;
    this.Of = _context;
    this.Cg.onaddtrack = this.Eg.bind(this);
    this.Cg.onremovetrack = this.Fg.bind(this);
    this.Cg.onchange = this.Gg.bind(this);
    listenEvent(this.Of.audioTracks, "change", this.Hg.bind(this));
  }
  get Cg() {
    return this.bb.media.audioTracks;
  }
  Eg(event) {
    const _track = event.track;
    if (_track.label === "")
      return;
    const audioTrack = {
      id: _track.id + "",
      label: _track.label,
      language: _track.language,
      kind: _track.kind,
      selected: false
    };
    this.Of.audioTracks[ListSymbol.h](audioTrack, event);
    if (_track.enabled)
      audioTrack.selected = true;
  }
  Fg(event) {
    const track = this.Of.audioTracks.getById(event.track.id);
    if (track)
      this.Of.audioTracks[ListSymbol.f](track, event);
  }
  Gg(event) {
    let enabledTrack = this.Dg();
    if (!enabledTrack)
      return;
    const track = this.Of.audioTracks.getById(enabledTrack.id);
    if (track)
      this.Of.audioTracks[ListSymbol.D](track, true, event);
  }
  Dg() {
    return Array.from(this.Cg).find((track) => track.enabled);
  }
  Hg(event) {
    const { current } = event.detail;
    if (!current)
      return;
    const track = this.Cg.getTrackById(current.id);
    if (track) {
      const prev = this.Dg();
      if (prev)
        prev.enabled = false;
      track.enabled = true;
    }
  }
}

class HTMLMediaProvider {
  constructor(_media) {
    this.w = null;
    this.v = _media;
  }
  setup(context) {
    new HTMLMediaEvents(this, context);
    if ("audioTracks" in this.media)
      new NativeAudioTracks(this, context);
    this.playsinline = context.$state.playsinline();
  }
  get type() {
    return "";
  }
  get media() {
    return this.v;
  }
  get currentSrc() {
    return this.w;
  }
  get paused() {
    return this.v.paused;
  }
  get muted() {
    return this.v.muted;
  }
  set muted(muted) {
    this.v.muted = muted;
  }
  get volume() {
    return this.v.volume;
  }
  set volume(volume) {
    this.v.volume = volume;
  }
  get currentTime() {
    return this.v.currentTime;
  }
  set currentTime(time) {
    this.v.currentTime = time;
  }
  get playsinline() {
    return this.v.hasAttribute("playsinline");
  }
  set playsinline(playsinline) {
    setAttribute(this.v, "playsinline", playsinline);
  }
  get playbackRate() {
    return this.v.playbackRate;
  }
  set playbackRate(rate) {
    this.v.playbackRate = rate;
  }
  async play() {
    return this.v.play();
  }
  async pause() {
    return this.v.pause();
  }
  async loadSource({ src, type }, preload) {
    this.v.preload = preload;
    if (isMediaStream(src)) {
      this.v.srcObject = src;
    } else {
      this.v.srcObject = null;
      this.v.src = isString(src) ? src : window.URL.createObjectURL(src);
    }
    this.v.load();
    this.w = { src, type };
  }
}

export { HTMLMediaProvider as H, RAFLoop as R };
